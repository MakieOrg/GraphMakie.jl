var documenterSearchIndex = {"docs":
[{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"EditURL = \"https://github.com/JuliaPlots/GraphMakie.jl/blob/master/docs/examples/truss.jl\"","category":"page"},{"location":"generated/truss/#Stress-on-Truss","page":"Stress on Truss","title":"Stress on Truss","text":"","category":"section"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"In this example we'll plot an animation of the stress on some truss structure using GaphMakie.jl and NetworkDynamics.jl","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"(Image: truss animation)","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"using NetworkDynamics\nusing OrdinaryDiffEq\nusing Graphs\nusing GraphMakie\nusing LinearAlgebra: norm, â‹…\nusing Printf\nusing CairoMakie\nCairoMakie.activate!()","category":"page"},{"location":"generated/truss/#Definition-of-the-dynamical-system","page":"Stress on Truss","title":"Definition of the dynamical system","text":"","category":"section"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Define dynamic model for NetworkDynamics","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"function edge_f!(e, v_s, v_d, (K, L), _)\n    Î”d = view(v_d, 1:2) - view(v_s, 1:2)\n    nd = norm(Î”d)\n    F = K * ( L - nd )\n    e[1:2] = F .* view(Î”d, 1:2) ./ nd\nend\n\nfunction vertex_free!(du, u, edges, (M, Î³, g), _)\n    F = sum(edges) - Î³ * view(u, 3:4) + [0, -M*g]\n    du[3:4] .= F ./ M\n    du[1:2] = view(u, 3:4)\nend\n\nfunction vertex_fixed!(du, u, edges, _, _)\n    du[1:2] .= 0.0\nend\n\nedge = StaticEdge(f = edge_f!, dim=2, coupling=:antisymmetric)\nvertex_free = ODEVertex(f = vertex_free!, dim=4, sym=[:x, :y, :v, :w])\nvertex_fix  = ODEVertex(f = vertex_fixed!, dim=2, sym=[:x, :y, :v, :w])\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Set up graph topology and initial positions.","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"N = 5\ndx = 1.0\nshift = 0.2\ng = SimpleGraph(2*N + 1)\nfor i in 1:N\n    add_edge!(g, i, i+N); add_edge!(g, i, i+N)\n    if i < N\n        add_edge!(g, i+1, i+N); add_edge!(g, i, i+1); add_edge!(g, i+N, i+N+1)\n    end\nend\nadd_edge!(g, 2N, 2N+1)\npos0 = zeros(Point2f, 2N + 1)\npos0[1:N] = [Point((i-1)dx,0) for i in 1:N]\npos0[N+1:2*N] = [Point(i*dx + shift, 1) for i in 1:N]\npos0[2N+1] = Point(N*dx + 1, -1)\n\nfixed = [1,4] # set fixed vertices\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"create networkdynamics object","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"vertices = ODEVertex[vertex_free for i in 1:nv(g)]\nfor i in fixed\n    vertices[i] = vertex_fix # use the fixed vertex for the fixed\nend\nnd = network_dynamics(vertices, edge, g);\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"write some auxiliary functions to map between state vector of DGL u and graph data","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"x_idxs = [findfirst(isequal(Symbol(\"x_$i\")), nd.syms) for i in 1:nv(g)]\n\n\"Set positions `pos` inside dgl state `u`\"\nfunction set_pos!(u, pos)\n    for (i, idx) in enumerate(x_idxs)\n        u[idx] = pos[i][1]\n        u[idx+1] = pos[i][2]\n    end\nend\n\n\"Extract vector of Points from dgl state `u`\"\nfunction to_pos(u)\n    pos = Vector{Point2f}(undef, nv(g))\n    for (i, idx) in enumerate(x_idxs)\n        pos[i] = Point(u[idx], u[idx+1])\n    end\n    return pos\nend\n\n\"Calculate load on edge for given state.\"\nfunction get_load(u, p, t=0.0)\n    gd_nd = nd(u, p, t, GetGD) # exposes underlying graph data struct\n    force = Vector{Float64}(undef, ne(g))\n    pos = to_pos(u)\n    for (i,e) in enumerate(edges(g))\n        edgeval = get_edge(gd_nd, i)\n        fvec = Point(edgeval[1], edgeval[2])\n        dir = pos[e.dst] .- pos[e.src]\n        force[i] = sign(fvec â‹… dir) * norm(fvec)\n    end\n    return force\nend\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Set parameters.","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"M = [10 for i in 1:nv(g)] # mass of the nodes\nM[end] = 200 # heavy mass\ngc = [9.81 for i in 1:nv(g)] # gravitational constant\nÎ³ = [200.0 for i in 1:nv(g)] # damping parameter\nÎ³[end] = 100.0\n\nL = [norm(pos0[e.src] - pos0[e.dst]) for e in edges(g)] # length of edges\nK = [0.5e6 for i in 1:ne(g)] # spring constant of edges\n\n# bundle parameters for NetworkDynamics\npara = collect.((zip(M, Î³, gc),\n                 zip(K, L)))\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Set initial state and solve the system","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"u0 = zeros(length(nd.syms))\nset_pos!(u0, pos0)\n\ntspan = (0.0, 12.0)\nprob = ODEProblem(nd, u0, tspan, para)\nsol  = solve(prob, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/truss/#Plot-the-solution","page":"Stress on Truss","title":"Plot the solution","text":"","category":"section"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"fig = Figure(resolution=(1000,550))\nfig[1,1] = title = Label(fig, \"Stress on truss\", textsize=30)\ntitle.tellwidth = false\n\nfig[2,1] = ax = Axis(fig)\n\n# calculate some values for colorscaling\n(fmin, fmax) = 0.3 .* extrema([(map(u->get_load(u, para), sol)...)...])\nnlabels = [\" \" for i in 1:nv(g)]\nnlabels[fixed] .= \"Î”\"\nelabels = [\"edge $i\" for i in 1:ne(g)]\np = graphplot!(ax, g;\n               edge_width=4.0,\n               node_size=sqrt.(M)*3,\n               nlabels=nlabels,\n               nlabels_align=(:center,:top),\n               nlabels_textsize=30,\n               elabels=elabels,\n               elabels_opposite=[ne(g)],\n               edge_color=[0.0 for i in 1:ne(g)],\n               edge_attr=(colorrange=(fmin,fmax),\n                          colormap=:diverging_bkr_55_10_c35_n256))\nhidespines!(ax); hidedecorations!(ax); p[:node_pos][]=to_pos(u0); ax.aspect = DataAspect()\nlimits!(ax, -0.1, pos0[end][1]+0.3, pos0[end][2]-0.5, 1.15)\n\n# draw colorbar\nfig[3,1] = cb = Colorbar(fig, p.plots[1], label = \"Axial force\", vertical=false)\n\nT = tspan[2]\nfps = 30\ntrange = range(0.0, sol.t[end], length=Int(T * fps))\nrecord(fig, \"truss.mp4\", trange; framerate=fps) do t\n    title.text = @sprintf \"Stress on truss (t = %.2f )\" t\n    p[:node_pos][] = to_pos(sol(t))\n    load = get_load(sol(t), para)\n    p.elabels = [@sprintf(\"%.0f\", l) for l in load]\n    p.edge_color[] = load\nend\nnothing #hide","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"","category":"page"},{"location":"generated/truss/","page":"Stress on Truss","title":"Stress on Truss","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"EditURL = \"https://github.com/JuliaPlots/GraphMakie.jl/blob/master/docs/examples/interactions.jl\"","category":"page"},{"location":"generated/interactions/#Add-interactions-to-your-graph-plot","page":"Interaction Examples","title":"Add interactions to your graph plot","text":"","category":"section"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"In this example you will see, how to register interactions with your graph plot. This tutorial will make use of the more basic Interaction Interface. If you just want to move nodes check out the Predefined Interactions. The implementation of those is quit similar to what is shown in this tutorial.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"We star with a simple wheel graph again. This time we use arrays for some attributes because we want to change them later in the interactions for individual nodes/edges.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") # hide\nset_theme!(resolution=(800, 400)) #hide\nCairoMakie.inline!(true) # hide\nusing GraphMakie\nusing Graphs\nusing CairoMakie.Colors\n\nimport Random; Random.seed!(2) # hide\ng = wheel_graph(10)\nf, ax, p = graphplot(g,\n                     edge_width = [2.0 for i in 1:ne(g)],\n                     edge_color = [colorant\"gray\" for i in 1:ne(g)],\n                     node_size = [10 for i in 1:nv(g)],\n                     node_color = [colorant\"red\" for i in 1:nv(g)])\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"Later on we want to enable drag interactions, therefore we disable the default :rectanglezoom interaction","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"deregister_interaction!(ax, :rectanglezoom)\nnothing #hide","category":"page"},{"location":"generated/interactions/#Hover-interactions","page":"Interaction Examples","title":"Hover interactions","text":"","category":"section"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"At first, let's add some hover interaction for our nodes using the NodeHoverHandler constructor. We need to define a action function with the signature fun(state, idx, event, axis). We use the action to make the nodes bigger on hover events.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"function node_hover_action(state, idx, event, axis)\n    @info idx #hide\n    p.node_size[][idx] = state ? 20 : 10\n    p.node_size[] = p.node_size[] # trigger observable\nend\nnhover = NodeHoverHandler(node_hover_action)\nregister_interaction!(ax, :nhover, nhover)\n\nfunction set_cursor!(p) #hide\n    direction = Point2f(-0.1, 0.2) #hide\n    arrows!([p-direction], [direction], linewidth=3, arrowsize=20, lengthscale=0.8) #hide\nend #hide\nnodepos = copy(p[:node_pos][]) #hide\nset_cursor!(nodepos[5] + Point2f(0.05, 0)) #hide\np.node_size[][5] = 20; p.node_size[] = p.node_size[] #hide\nf #hide","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"Please run the script locally with GLMakie.jl if you want to play with the Graph ðŸ™‚ The edge hover interaction is quite similar:","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"pop!(ax.scene.plots) #hide\np.node_size[][5] = 10; p.node_size[] = p.node_size[] #hide\nfunction edge_hover_action(state, idx, event, axis)\n    @info idx #hide\n    p.edge_width[][idx]= state ? 5.0 : 2.0\n    p.edge_width[] = p.edge_width[] # trigger observable\nend\nehover = EdgeHoverHandler(edge_hover_action)\nregister_interaction!(ax, :ehover, ehover)\n\nset_cursor!((nodepos[4]+nodepos[1])/2) #hide\np.edge_width[][3] = 5.0; p.edge_width[] = p.edge_width[] #hide\nf #hide","category":"page"},{"location":"generated/interactions/#Click-interactions","page":"Interaction Examples","title":"Click interactions","text":"","category":"section"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"In a similar fashion we might change the color of nodes and lines by click.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"function node_click_action(idx, args...)\n    p.node_color[][idx] = rand(RGB)\n    p.node_color[] = p.node_color[]\nend\nnclick = NodeClickHandler(node_click_action)\nregister_interaction!(ax, :nclick, nclick)\n\nfunction edge_click_action(idx, args...)\n    p.edge_color[][idx] = rand(RGB)\n    p.edge_color[] = p.edge_color[]\nend\neclick = EdgeClickHandler(edge_click_action)\nregister_interaction!(ax, :eclick, eclick)\n\np.edge_color[][3] = colorant\"blue\"; p.edge_color[] = p.edge_color[] #hide\np.node_color[][7] = colorant\"yellow\" #hide\np.node_color[][2] = colorant\"brown\" #hide\np.node_color[][9] = colorant\"pink\" #hide\np.node_color[][6] = colorant\"green\" #hide\np.node_color[] = p.node_color[] #hide\nf #hide","category":"page"},{"location":"generated/interactions/#Drag-interactions","page":"Interaction Examples","title":"Drag interactions","text":"","category":"section"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"pop!(ax.scene.plots) #hide\np.edge_width[][3] = 2.0; p.edge_width[] = p.edge_width[] #hide\nfunction node_drag_action(state, idx, event, axis)\n    p[:node_pos][][idx] = event.data\n    p[:node_pos][] = p[:node_pos][]\nend\nndrag = NodeDragHandler(node_drag_action)\nregister_interaction!(ax, :ndrag, ndrag)\n\np[:node_pos][][1] = nodepos[1] + Point2f(1.0,0.5) #hide\np[:node_pos][] = p[:node_pos][] #hide\nset_cursor!(p[:node_pos][][1] + Point2f(0.05, 0)) #hide\np.node_size[][1] = 20; p.node_size[] = p.node_size[] #hide\nf # hide","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"The last example is not as straight forward. By dragging an edge we want to change the positions of both attached nodes. Therefore we need some more state inside the action. We can achieve this with a callable struct.","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"pop!(ax.scene.plots) #hide\np.node_size[][1] = 10; p.node_size[] = p.node_size[] #hide\nmutable struct EdgeDragAction\n    init::Union{Nothing, Point2f} # save click position\n    src::Union{Nothing, Point2f}  # save src vertex position\n    dst::Union{Nothing, Point2f}  # save dst vertex position\n    EdgeDragAction() = new(nothing, nothing, nothing)\nend\nfunction (action::EdgeDragAction)(state, idx, event, axis)\n    edge = collect(edges(g))[idx]\n    if state == true\n        if action.src===action.dst===action.init===nothing\n            action.init = event.data\n            action.src = p[:node_pos][][edge.src]\n            action.dst = p[:node_pos][][edge.dst]\n        end\n        offset = event.data - action.init\n        p[:node_pos][][edge.src] = action.src + offset\n        p[:node_pos][][edge.dst] = action.dst + offset\n        p[:node_pos][] = p[:node_pos][] # trigger change\n    elseif state == false\n        action.src = action.dst = action.init =  nothing\n    end\nend\nedrag = EdgeDragHandler(EdgeDragAction())\nregister_interaction!(ax, :edrag, edrag)\n\np[:node_pos][][9] = nodepos[9] + Point2f(0.9,1.0) #hide\np[:node_pos][][10] = nodepos[10] + Point2f(0.9,1.0) #hide\np[:node_pos][] = p[:node_pos][] #hide\npm = (p[:node_pos][][9] + p[:node_pos][][10])/2 #hide\nset_cursor!(pm) #hide\np.edge_width[][18] = 5.0; p.edge_width[] = p.edge_width[] #hide\nf # hide","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"","category":"page"},{"location":"generated/interactions/","page":"Interaction Examples","title":"Interaction Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"EditURL = \"https://github.com/JuliaPlots/GraphMakie.jl/blob/master/docs/examples/syntaxtree.jl\"","category":"page"},{"location":"generated/syntaxtree/#AST-of-a-Julia-function","page":"Julia AST","title":"AST of a Julia function","text":"","category":"section"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"In this example we are going to plot an abstract syntax tree of a Julia function using the Bucheim Layout from NetworkLayout.jl.","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") #hide\nCairoMakie.inline!(true) #hide\nset_theme!(resolution=(800, 600)) #hide\nusing Graphs\nusing GraphMakie\nusing NetworkLayout\nusing CairoMakie","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"The following code, which walks the AST and creats a SimpleDiGraph was taken and slightly modified from TreeView.jl. Thanks!","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"function walk_tree(ex; show_call=true)\n    g = SimpleDiGraph()\n    labels = Any[]\n    walk_tree!(g, labels, ex, show_call)\n    return (g, labels)\nend\n\nfunction walk_tree!(g, labels, ex, show_call)\n    add_vertex!(g)\n    top_vertex = vertices(g)[end]\n\n    where_start = 1  # which argument to start with\n\n    if !(show_call) && ex.head == :call\n        f = ex.args[1]   # the function name\n        push!(labels, f)\n        where_start = 2   # drop \"call\" from tree\n    else\n        push!(labels, ex.head)\n    end\n\n    for i in where_start:length(ex.args)\n        if isa(ex.args[i], Expr)\n            child = walk_tree!(g, labels, ex.args[i], show_call)\n            add_edge!(g, top_vertex, child)\n        elseif !isa(ex.args[i], LineNumberNode)\n            add_vertex!(g)\n            n = vertices(g)[end]\n            add_edge!(g, top_vertex, n)\n            push!(labels, ex.args[i])\n        end\n    end\n\n    return top_vertex\nend\nnothing #hide","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"The expression we want to look at is the recursive definition of the Fibonacci sequence.","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"expr = quote\n    function fib(n)\n        if n > 1\n            return fib(n-1) + fib(n-2)\n        else\n            return n\n        end\n    end\nend\n\ng, labels = walk_tree(expr, show_call=true)\nnlabels_align = [(:left, :bottom) for v in vertices(g)]\nfig, ax, p = graphplot(g; layout=Buchheim(),\n                       nlabels=repr.(labels),\n                       nlabels_distance=5,\n                       nlabels_align,\n                       tangents=((0,-1),(0,-1)))\nhidedecorations!(ax); hidespines!(ax)\nfig #hide","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"This does not look nice yet! Lets tweak the align parameter of the nodes labels...","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"for v in vertices(g)\n    if isempty(inneighbors(g, v)) # root\n        nlabels_align[v] = (:center,:bottom)\n    elseif isempty(outneighbors(g, v)) #leaf\n        nlabels_align[v] = (:center,:top)\n    else\n        self = p[:node_pos][][v]\n        parent = p[:node_pos][][inneighbors(g, v)[1]]\n        if self[1] < parent[1] # left branch\n            nlabels_align[v] = (:right,:bottom)\n        end\n    end\nend\np.nlabels_align = nlabels_align\nfig # hide","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"","category":"page"},{"location":"generated/syntaxtree/","page":"Julia AST","title":"Julia AST","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphMakie","category":"page"},{"location":"#GraphMakie","page":"Home","title":"GraphMakie","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the Documentation for GraphMakie.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Package consists of two parts: a plot recipe for graphs types from Graphs.jl and some helper functions to add interactions to those plots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: about Graphs.jl and LightGraphs.jl\nStarting from v0.3 GraphMakie.jl switches from LightGraphs.jl to Graphs.jl as the for the underlying graph package. See this discourse post for more information. If you want to use LightGraphs.jl please specifically ] add GraphMakie@0.2!","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are also plot examples and interaction examples pages.","category":"page"},{"location":"#The-graphplot-Recipe","page":"Home","title":"The graphplot Recipe","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"graphplot","category":"page"},{"location":"#GraphMakie.graphplot","page":"Home","title":"GraphMakie.graphplot","text":"graphplot(graph::AbstractGraph)\ngraphplot!(ax, graph::AbstractGraph)\n\nCreates a plot of the network graph. Consists of multiple steps:\n\nLayout the nodes: see layout attribute. The node position is accessible from outside the plot object p as an observable using p[:node_pos].\nplot edges as edgeplot-plot\nif arrow_show plot arrowheads as scatter-plot\nplot nodes as scatter-plot\nif nlabels!=nothing plot node labels as text-plot\nif elabels!=nothing plot edge labels as text-plot\n\nThe main attributes for the subplots are exposed as attributes for graphplot. Additional attributes for the scatter, edgeplot and text plots can be provided as a named tuples to node_attr, edge_attr, nlabels_attr and elabels_attr.\n\nMost of the arguments can be either given as a vector of length of the edges/nodes or as a single value. One might run into errors when changing the underlying graph and therefore changing the number of Edges/Nodes.\n\nAttributes\n\nMain attributes\n\nlayout=Spring(): function AbstractGraph->Vector{Point} determines the base layout\nnode_color=scatter_theme.color\nnode_size=scatter_theme.markersize\nnode_marker=scatter_theme.marker\nnode_attr=(;): List of kw arguments which gets passed to the scatter command\nedge_color=lineseg_theme.color: Color for edges.\nedge_width=lineseg_theme.linewidth: Pass a vector with 2 width per edge to get pointy edges.\nedge_attr=(;): List of kw arguments which gets passed to the linesegments command\narrow_show=Makie.automatic: Bool, indicate edge directions with arrowheads? Defaults to Graphs.is_directed(graph).\narrow_size=scatter_theme.markersize: Size of arrowheads.\narrow_shift=0.5: Shift arrow position from source (0) to dest (1) node.\narrow_attr=(;): List of kw arguments which gets passed to the scatter command\n\nNode labels\n\nThe position of each label is determined by the node position plus an offset in data space.\n\nnlabels=nothing: Vector{String} with label for each node\nnlabels_align=(:left, :bottom): Anchor of text field.\nnlabels_distance=0.0: Pixel distance from node in direction of align.\nnlabels_color=labels_theme.color\nnlabels_offset=nothing: Point or Vector{Point} (in data space)\nnlabels_textsize=labels_theme.textsize\nnlabels_attr=(;): List of kw arguments which gets passed to the text command\n\nEdge labels\n\nThe base position of each label is determinded by src + shift*(dst-src). The additional distance parameter is given in pixels and shifts the text away from the edge.\n\nelabels=nothing: Vector{String} with label for each edge\nelabels_align=(:center, :bottom): Anchor of text field.\nelabels_distance=0.0: Pixel distance of anchor to edge.\nelabels_shift=0.5: Position between src and dst of edge.\nelabels_opposite=Int[]: List of edge indices, for which the label should be displayed on the opposite side\nelabels_rotation=nothing: Angle of text per label. If nothing this will be determined by the edge angle!\nelabels_offset=nothing: Additional offset in data space\nelabels_color=labels_theme.color\nelabels_textsize=labels_theme.textsize\nelabels_attr=(;): List of kw arguments which gets passed to the text command\n\nCurvy edges & self edges/loops\n\nedge_plottype=Makie.automatic(): Either automatic, :linesegments or :beziersegments. :beziersegments are much slower for big graphs!\n\nSelf edges / loops:\n\nselfedge_size=Makie.automatic(): Size of self-edge-loop (dict/vector possible).\nselfedge_direction=Makie.automatic(): Direction of self-edge-loop as Point2 (dict/vector possible).\nselfedge_width=Makie.automatic(): Opening of selfloop in rad (dict/vector possible).\n\nHigh level interface for curvy edges:\n\ncurve_distance=0.1:\nSpecify a distance of the (now curved) line to the straight line in data   space. Can be single value, array or dict. User proivded tangents or   waypoints will overrule this property.\ncurve_distance_usage=Makie.automatic():\nIf Makie.automatic(), only plot double edges in a curvy way. Other options   are true and false.\n\nTangents interface for curvy edges:\n\ntangents=nothing:\nSpecify a pair of tangent vectors per edge (for src and dst). If nothing   (or edge idx not in dict) draw a straight line.\ntfactor=0.6:\nFactor is used to calculate the bezier waypoints from the (normalized) tangents.   Higher factor means bigger radius. Can be tuple per edge to specify different   factor for src and dst.\n\nWaypoints along edges:\n\nwaypoints=nothing\nSpecify waypoints for edges. This parameter should be given as a vector or   dict. Waypoints will be crossed using natural cubic splines. The waypoints may   or may not include the src/dst positions.\nwaypoint_radius=nothing: If number (dict/vector possible) bent lines within radius of waypoints.\n\n\n\n\n\n","category":"function"},{"location":"#Network-Layouts","page":"Home","title":"Network Layouts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The layout algorithms are provided by NetworkLayout.jl. See the docs for a list of available layouts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A layout has to be a function f(g::AbstractGraph) -> pos::Vector{Point}. You can also provide your own layouts or use other packages like LayeredLayouts.jl for DAG (see also the Dependency Graph of a Package example).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LayeredLayouts\nfunction mylayout(g::SimpleGraph)\n   xs, ys, _ = solve_positions(Zarate(), g)\n   return Point.(zip(xs, ys))\nend","category":"page"},{"location":"#Predefined-Interactions","page":"Home","title":"Predefined Interactions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphMakie.jl provides some pre-built interactions to enable drag&drop of nodes and edges as well as highlight on hover.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To try them all use the following code in a GLMakie environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie\nusing GraphMakie\nusing Graphs\ng = wheel_graph(10)\nf, ax, p = graphplot(g, edge_width=[3 for i in 1:ne(g)],\n                     node_size=[10 for i in 1:nv(g)])\n\nderegister_interaction!(ax, :rectanglezoom)\nregister_interaction!(ax, :nhover, NodeHoverHighlight(p))\nregister_interaction!(ax, :ehover, EdgeHoverHighlight(p))\nregister_interaction!(ax, :ndrag, NodeDrag(p))\nregister_interaction!(ax, :edrag, EdgeDrag(p))","category":"page"},{"location":"","page":"Home","title":"Home","text":"NodeHoverHighlight\nEdgeHoverHighlight\nNodeDrag\nEdgeDrag","category":"page"},{"location":"#GraphMakie.NodeHoverHighlight","page":"Home","title":"GraphMakie.NodeHoverHighlight","text":"NodeHoverHeighlight(p::GraphPlot, factor=2)\n\nMagnifies the node_size of node under cursor by factor.\n\nExample\n\njulia> g = wheel_graph(10)\njulia> f, ax, p = graphplot(g, node_size = [20 for i in 1:nv(g)])\njulia> register_interaction!(ax, :nodehover, NodeHoverHighlight(p))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.EdgeHoverHighlight","page":"Home","title":"GraphMakie.EdgeHoverHighlight","text":"EdgeHoverHeighlight(p::GraphPlot, factor=2)\n\nMagnifies the edge_width of edge under cursor by factor. If arrow_size isa Vector{<:Real} it also magnefies the arrow scatter.\n\nExample\n\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, edge_width = [3 for i in 1:ne(g)],\n                               arrow_size=[10 for i in 1:ne(g)])\njulia> register_interaction!(ax, :nodehover, EdgeHoverHighlight(p))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.NodeDrag","page":"Home","title":"GraphMakie.NodeDrag","text":"NodeDrag(p::GraphPlot)\n\nAllows drag and drop of Nodes. Please deregister the :rectanglezoom interaction.\n\nExample\n\njulia> g = wheel_graph(10)\njulia> f, ax, p = graphplot(g, node_size = [10 for i in 1:nv(g)])\njulia> deregister_interaction!(ax, :rectanglezoom)\njulia> register_interaction!(ax, :nodehover, NodeHoverHighlight(p))\njulia> register_interaction!(ax, :nodedrag, NodeDrag(p))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.EdgeDrag","page":"Home","title":"GraphMakie.EdgeDrag","text":"EdgeDrag(p::GraphPlot)\n\nAllows drag and drop of Edges. Please deregister the :rectanglezoom interaction.\n\nExample\n\njulia> g = wheel_graph(10)\njulia> f, ax, p = graphplot(g, edge_width = [3 for i in 1:ne(g)])\njulia> deregister_interaction!(ax, :rectanglezoom)\njulia> register_interaction!(ax, :edgehover, EdgeHoverHighlight(p))\njulia> register_interaction!(ax, :edgedrag, EdgeDrag(p))\n\n\n\n\n\n","category":"function"},{"location":"#Interaction-Interface","page":"Home","title":"Interaction Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphMakie.jl provides some helper functions to register interactions to your graph plot. There are special interaction types for hovering, clicking and draging nodes and edges. For more information on the axis interaction please consult the Makie.jl docs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The general idea is to create some handler type, provide some action function and register it as an interaction with the axes.","category":"page"},{"location":"#Click-Interactions","page":"Home","title":"Click Interactions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NodeClickHandler\nEdgeClickHandler","category":"page"},{"location":"#GraphMakie.NodeClickHandler","page":"Home","title":"GraphMakie.NodeClickHandler","text":"NodeClickHandler(fun)\n\nInitializes ClickHandler for nodes. Calls function\n\nfun(idx, event, axis)\n\non left-click events where idx is the node index.\n\nExample\n\njulia> using Makie.Colors\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, node_size=30, node_color=[colorant\"red\" for i in 1:nv(g)])\njulia> function action(idx, event, axis)\n           p.node_color[][idx] = rand(RGB)\n           p.node_color[] = p.node_color[]\n       end\njulia> register_interaction!(ax, :nodeclick, NodeClickHandler(action))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.EdgeClickHandler","page":"Home","title":"GraphMakie.EdgeClickHandler","text":"EdgeClickHandler(fun)\n\nInitializes ClickHandler for edges. Calls function\n\nfun(idx, event, axis)\n\non left-click events where idx is the edge index.\n\nExample\n\njulia> using Makie.Colors\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, edge_width=4, edge_color=[colorant\"black\" for i in 1:ne(g)])\njulia> function action(idx, event, axis)\n           p.edge_color[][idx] = rand(RGB)\n           p.edge_color[] = p.edge_color[]\n       end\njulia> register_interaction!(ax, :edgeclick, EdgeClickHandler(action))\n\n\n\n\n\n","category":"function"},{"location":"#Hover-Interactions","page":"Home","title":"Hover Interactions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NodeHoverHandler\nEdgeHoverHandler","category":"page"},{"location":"#GraphMakie.NodeHoverHandler","page":"Home","title":"GraphMakie.NodeHoverHandler","text":"NodeHoverHandler(fun)\n\nInitializes HoverHandler for nodes. Calls function\n\nfun(hoverstate, idx, event, axis)\n\nwith hoverstate=true on hover and false at the end of hover. idx is the node index.\n\nExample\n\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, node_size = [20 for i in 1:nv(g)])\njulia> function action(state, idx, event, axis)\n           p.node_size[][idx] = state ? 40 : 20\n           p.node_size[] = p.node_size[] #trigger observable\n       end\njulia> register_interaction!(ax, :nodehover, NodeHoverHandler(action))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.EdgeHoverHandler","page":"Home","title":"GraphMakie.EdgeHoverHandler","text":"EdgeHoverHandler(fun)\n\nInitializes HoverHandler for edges. Calls function\n\nfun(hoverstate, idx, event, axis)\n\nwith hoverstate=true on hover and false at the end of hover. idx is the edge index.\n\nExample\n\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, edge_width = [3.0 for i in 1:ne(g)])\njulia> function action(state, idx, event, axis)\n           p.edge_width[][idx] = state ? 6.0 : 3.0\n           p.edge_width[] = p.edge_width[] #trigger observable\n       end\njulia> register_interaction!(ax, :edgehover, EdgeHoverHandler(action))\n\n\n\n\n\n","category":"function"},{"location":"#Drag-Interactions","page":"Home","title":"Drag Interactions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NodeDragHandler\nEdgeDragHandler","category":"page"},{"location":"#GraphMakie.NodeDragHandler","page":"Home","title":"GraphMakie.NodeDragHandler","text":"NodeDragHandler(fun)\n\nInitializes DragHandler for Nodes. Calls function\n\nfun(dragstate, idx, event, axis)\n\nwhere dragstate=true during the drag and false at the end of the drag, the last time fun is triggered. idx is the node index.\n\nExample\n\njulia> g = wheel_digraph(10)\njulia> f, ax, p = graphplot(g, node_size=20)\njulia> deregister_interaction!(ax, :rectanglezoom)\njulia> function action(state, idx, event, axis)\n           p[:node_pos][][idx] = event.data\n           p[:node_pos][] = p[:node_pos][]\n       end\njulia> register_interaction!(ax, :nodedrag, NodeDragHandler(action))\n\n\n\n\n\n","category":"function"},{"location":"#GraphMakie.EdgeDragHandler","page":"Home","title":"GraphMakie.EdgeDragHandler","text":"EdgeDragHandler(fun)\n\nInitializes DragHandler for Edges. Calls function\n\nfun(dragstate, idx, event, axis)\n\nwhere dragstate=true during the drag and false at the end of the drag, the last time fun is triggered. idx is the edge index.\n\nSee EdgeDrag for a concrete implementation. ```\n\n\n\n\n\n","category":"function"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"EditURL = \"https://github.com/JuliaPlots/GraphMakie.jl/blob/master/docs/examples/depgraph.jl\"","category":"page"},{"location":"generated/depgraph/#Dependency-Graph-of-a-Package","page":"Dependency Graph","title":"Dependency Graph of a Package","text":"","category":"section"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"In this example we'll plot a dependency graph of a package using PkgDeps.jl and and a DAG layout from LayeredLayouts.jl","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") #hide\nCairoMakie.inline!(true) #hide\nset_theme!(resolution=(800, 600)) #hide\nusing GraphMakie\nusing Graphs\nusing LayeredLayouts\nusing PkgDeps\nusing Makie.GeometryBasics\nusing Makie.Colors","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"First we need a small function which goes recursively through the dependencies of a package and builds a SimpleDiGraph object.","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"function depgraph(root)\n    packages = [root]\n    connections = Vector{Pair{Int,Int}}()\n\n    for pkg in packages\n        pkgidx = findfirst(isequal(pkg), packages)\n        deps = direct_dependencies(pkg)\n\n        for dep in keys(deps)\n            idx = findfirst(isequal(dep), packages)\n            if idx === nothing\n                push!(packages, dep)\n                idx = lastindex(packages)\n            end\n            push!(connections, idx => pkgidx)\n        end\n    end\n    g = SimpleDiGraph(length(packages))\n    for c in connections\n        add_edge!(g, c)\n    end\n    return (packages, g)\nend\nnothing #hide","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"As an example we'll plot the dependency Graph of Revise.jl because it is one of the most important packages in the Julia ecosystem but does not have a huge dependency tree.","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"(packages, g) = depgraph(\"Revise\")\nN = length(packages)\nxs, ys, paths = solve_positions(Zarate(), g)\n\n# we scale the y coordinates so the plot looks nice in `DataAspect()`\nys .= 0.3 .* ys\nforeach(v -> v[2] .= 0.3 .* v[2], values(paths))\nnothing #hide","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"In GraphMakie the layout always needs to be function. So we're creating a dummy function... We will use the Edge waypoints attribute to get the graph with the least crossings.","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"lay = _ -> Point.(zip(xs,ys))\n# create a vector of Point2f per edge\nwp = [Point2f.(zip(paths[e]...)) for e in edges(g)]\n\n# manually tweak some of the lable aligns\nalign = [(:right, :center) for i in 1:N]\nalign[1]  = (:left, :center)  # Revise\nalign[3]  = (:right, :top)    # LoweredCodeUtils\nalign[6]  = (:left, :bottom)  # CodeTracking\nalign[10] = (:left, :bottom)  # JuliaInterpreter\nalign[13] = (:left, :bottom)  # Requires\n\n# shift \"JuliaInterpreter\" node in data space\noffset = [Point2f(0,0) for i in 1:N]\noffset[10] = Point(-0.1, 0.1)\n\nf, ax, p = graphplot(g; layout=lay,\n                     arrow_size=15,\n                     edge_color=:gray,\n                     nlabels=packages,\n                     nlabels_align=align,\n                     nlabels_distance=10,\n                     nlabels_textsize=15,\n                     nlabels_offset=offset,\n                     node_size=[9.0 for i in 1:N],\n                     edge_width=[3 for i in 1:ne(g)],\n                     waypoints=wp,\n                     waypoint_radius=0.5)\nax.title = \"Dependency Graph of Revise.jl\"\nxlims!(ax, -0.6, 5.6)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf #hide","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"If you run this example using GLMakie you can add this code to play around with the interactive features.","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"deregister_interaction!(ax, :rectanglezoom)\nregister_interaction!(ax, :nodehover, NodeHoverHighlight(p))\nregister_interaction!(ax, :edgehover, EdgeHoverHighlight(p))\nregister_interaction!(ax, :edrag, EdgeDrag(p))\nregister_interaction!(ax, :ndrag, NodeDrag(p))","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"","category":"page"},{"location":"generated/depgraph/","page":"Dependency Graph","title":"Dependency Graph","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"EditURL = \"https://github.com/JuliaPlots/GraphMakie.jl/blob/master/docs/examples/plots.jl\"","category":"page"},{"location":"generated/plots/#Plotting-Graphs-with-GraphMakie.jl","page":"Feature Walkthrough","title":"Plotting Graphs with GraphMakie.jl","text":"","category":"section"},{"location":"generated/plots/#The-graphplot-Command","page":"Feature Walkthrough","title":"The graphplot Command","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Plotting your first AbstractGraph from Graphs.jl is as simple as","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") # hide\nset_theme!(resolution=(800, 400)) #hide\nCairoMakie.inline!(true) # hide\nusing GraphMakie\nusing Graphs\nimport Random; Random.seed!(2) # hide\n\ng = wheel_graph(10)\nf, ax, p = graphplot(g)\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The graphplot command is a recipe which wraps several steps","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"layout the graph in space using a layout function,\ncreate a scatter plot for the nodes and\ncreate a linesegments plot for the edges.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The default layout is Spring() from NetworkLayout.jl. The layout attribute can be any function which takes an AbstractGraph and returns a list of Point{dim,Ptype} (see GeometryBasics.jl objects where dim determines the dimensionality of the plot.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Besides that there are some common attributes which are forwarded to the underlying plot commands. See graphplot.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using GraphMakie.NetworkLayout\n\ng = SimpleGraph(5)\nadd_edge!(g, 1, 2); add_edge!(g, 2, 4);\nadd_edge!(g, 4, 3); add_edge!(g, 3, 2);\nadd_edge!(g, 2, 5); add_edge!(g, 5, 4);\nadd_edge!(g, 4, 1); add_edge!(g, 1, 5);\n\n# define some edge colors\nedgecolors = [:black for i in 1:ne(g)]\nedgecolors[4] = edgecolors[7] = :red\n\nf, ax, p = graphplot(g, layout=Shell(),\n                     node_color=[:black, :red, :red, :red, :black],\n                     edge_color=edgecolors)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nf #hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"We can interactively change the attributes as usual with Makie.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"fixed_layout(_) = [(0,0), (0,1), (0.5, 1.5), (1,1), (1,0)]\n# set new layout\np.layout = fixed_layout; autolimits!(ax)\n# change edge width & color\np.edge_width = 5.0\np.edge_color[][3] = :green;\np.edge_color = p.edge_color[] # trigger observable\nf #hide","category":"page"},{"location":"generated/plots/#Adding-Node-Labels","page":"Feature Walkthrough","title":"Adding Node Labels","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Random.seed!(2)\ng = wheel_graph(10)\n\ncolors = [:black for i in 1:nv(g)]\ncolors[1] = :red\n\nf, ax, p = graphplot(g,\n                     nlabels=repr.(1:nv(g)),\n                     nlabels_color=colors,\n                     nlabels_align=(:center,:center))\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This is not very nice, lets change the offsets based on the node_positions","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"offsets = 0.15 * (p[:node_pos][] .- p[:node_pos][][1])\noffsets[1] = Point2f(0, 0.3)\np.nlabels_offset[] = offsets\nautolimits!(ax)\nf # hide","category":"page"},{"location":"generated/plots/#Adding-Edge-Labels","page":"Feature Walkthrough","title":"Adding Edge Labels","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Random.seed!(42)\ng = barabasi_albert(6, 2)\n\nlabels =  repr.(1:ne(g))\n\nf, ax, p = graphplot(g, elabels=labels,\n                     elabels_color=[:black for i in 1:ne(g)],\n                     edge_color=[:black for i in 1:ne(g)])\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The position of the edge labels is determined by several plot arguments. All possible arguments are described in the docs of the graphplot function.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Basicially, each label is placed in the middle of the edge and rotated to match the edge rotation. The rotaion for each label can be overwritten with the elabels_rotation argument.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"p.elabels_rotation[] = Vector{Union{Nothing, Float64}}(nothing, ne(g))\np.elabels_rotation[][5] = 0.0 # set absolute rotation angle for label 5\np.elabels_rotation[] = p.elabels_rotation[]\nnothing #hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"One can shift the label along the edge with the elabels_shift argument and determine the distance in pixels using the elabels_distance argument.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"p.elabels_opposite[] = [1,2,8,6]\n\np.elabels_offset[] = [Point2f(0.0, 0.0) for i in 1:ne(g)]\np.elabels_offset[][5] = Point2f(-0.4,0)\np.elabels_offset[] = p.elabels_offset[]\n\np.elabels_shift[] = [0.5 for i in 1:ne(g)]\np.elabels_shift[][1] = 0.6\np.elabels_shift[][7] = 0.4\np.elabels_shift[] = p.elabels_shift[]\n\np.elabels_distance[] = zeros(ne(g))\np.elabels_distance[][8] = 15\np.elabels_distance[] = p.elabels_distance[]\n\nf # hide","category":"page"},{"location":"generated/plots/#Indicate-Edge-Direction","page":"Feature Walkthrough","title":"Indicate Edge Direction","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is possible to put arrows on the edges using the arrow_show parameter. This parameter is true for SimpleDiGraph by default. The position and size of each arrowhead can be change using the arrow_shift and arrow_size parameters.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"g = wheel_digraph(10)\narrow_size = [10+i for i in 1:ne(g)]\narrow_shift = range(0.1, 0.8, length=ne(g))\nf, ax, p = graphplot(g; arrow_size, arrow_shift)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/#Self-edges","page":"Feature Walkthrough","title":"Self edges","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"A self edge in a graph will be displayed as a loop.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"note: Note\nSelfe edges are not possible in 3D plots yet.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"g = complete_graph(3)\nadd_edge!(g, 1, 1)\nadd_edge!(g, 2, 2)\nadd_edge!(g, 3, 3)\nf, ax, p = graphplot(g)\n\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is possible to change the appearance using the selfedge_ attributes:","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"p.selfedge_size = Dict(1=>Makie.automatic, 4=>3.6, 6=>0.5) #idx as in edges(g)\np.selfedge_direction = Point2f(0.3, 1)\np.selfedge_width = Any[Makie.automatic for i in 1:ne(g)]\np.selfedge_width[][4] = 0.6*Ï€; notify(p.selfedge_width)\nautolimits!(ax)\nf # hide","category":"page"},{"location":"generated/plots/#Curvy-edges","page":"Feature Walkthrough","title":"Curvy edges","text":"","category":"section"},{"location":"generated/plots/#curve_distance-interface","page":"Feature Walkthrough","title":"curve_distance interface","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The easiest way to enable curvy edges is to use the curve_distance parameter which lets you add a \"distance\" parameter. The parameter changes the maximum distance of the bent line to a straight line. Per default, only two way edges will be drawn as a curve:","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"g = SimpleDiGraph(3); add_edge!(g, 1, 2); add_edge!(g, 2, 3); add_edge!(g, 3, 1); add_edge!(g, 1, 3)\n\nf, ax, p = graphplot(g)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf #hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This behaviour may be changed by using the curve_distance_usage=Makie.automatic parameter.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Makie.automatic: Only apply curve_distance to double edges.\ntrue: Use on all edges.\nfalse: Don't use.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"f, ax, p = graphplot(g; curve_distance=-.5, curve_distance_usage=true)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf #hide","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is also possible to specify the distance on a per edge base:","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"g = complete_digraph(3)\ndistances = collect(0.05:0.05:ne(g)*0.05)\nelabels = \"d = \".* repr.(round.(distances, digits=2))\nf, ax, p = graphplot(g; curve_distance=distances, elabels, arrow_size=20)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/#tangents-interface","page":"Feature Walkthrough","title":"tangents interface","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Curvy edges are also possible using the low level interface of passing tangent vectors and a tfactor. The tangent vectors can be nothing (straight line) or two vectors per edge (one for src vertex, one for dst vertex). The tfactor scales the distance of the bezier control point relative to the distance of src and dst nodes. For real world usage see the AST of a Julia function example.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using GraphMakie: plot_controlpoints!\ng = complete_graph(3)\ntangents = Dict(1 => ((1,1),(0,-1)),\n                2 => ((0,1),(0,-1)),\n                3 => ((0,-1),(1,0)))\ntfactor = [0.5, 0.75, (0.5, 0.25)]\nf, ax, p = graphplot(g; layout=SquareGrid(cols=3), tangents, tfactor,\n                     arrow_size=20, arrow_show=true, edge_color=[:red, :green, :blue],\n                     elabels=\"Edge \".*repr.(1:ne(g)), elabels_distance=10)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nplot_controlpoints!(ax, p) # show control points for demonstration\nf # hide","category":"page"},{"location":"generated/plots/#Edge-waypoints","page":"Feature Walkthrough","title":"Edge waypoints","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is possible to specify waypoints per edge which needs to be crossed. See the Dependency Graph of a Package example.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"If the attribute waypoint_radius is nothing or :spline the waypoints will be crossed using natural cubic spline interpolation. If the supply a radius the waypoints won't be reached, instead they will be connected with straight lines which bend in the given radius around the waypoints.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"set_theme!(resolution=(800, 800)) #hide\ng = SimpleGraph(8); add_edge!(g, 1, 2); add_edge!(g, 3, 4); add_edge!(g, 5, 6); add_edge!(g, 7, 8)\n\nwaypoints = Dict(1 => [(.25,  0.25), (.75, -0.25)],\n                 2 => [(.25, -0.25), (.75, -0.75)],\n                 3 => [(.25, -0.75), (.75, -1.25)],\n                 4 => [(.25, -1.25), (.75, -1.75)])\nwaypoint_radius = Dict(1 => nothing,\n                       2 => 0,\n                       3 => 0.05,\n                       4 => 0.15)\n\nf = Figure(); f[1,1] = ax = Axis(f)\nusing Makie.Colors # hide\nfor i in 3:4 #hide\n    poly!(ax, Circle(Point2f(waypoints[i][1]), waypoint_radius[i]), color=RGBA(0.0,0.44705883,0.69803923,0.2)) #hide\n    poly!(ax, Circle(Point2f(waypoints[i][2]), waypoint_radius[i]), color=RGBA(0.0,0.44705883,0.69803923,0.2)) #hide\nend #hide\n\np = graphplot!(ax, g; layout=SquareGrid(cols=2, dy=-0.5),\n               waypoints, waypoint_radius,\n               nlabels=[\"\",\"r = nothing (equals :spline)\",\n                        \"\",\"r = 0 (straight lines)\",\n                        \"\",\"r = 0.05 (in data space)\",\n                        \"\",\"r = 0.1\"],\n               nlabels_distance=30, nlabels_align=(:left,:center))\n\nfor i in 1:4 #hide\n    scatter!(ax, waypoints[i], color=RGBA(0.0,0.44705883,0.69803923,1.0)) #hide\nend #hide\nxlims!(ax, (-0.1, 2.25)), hidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\nf # hide","category":"page"},{"location":"generated/plots/#Plot-Graphs-in-3D","page":"Feature Walkthrough","title":"Plot Graphs in 3D","text":"","category":"section"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"If the layout returns points in 3 dimensions, the plot will be in 3D. However this is a bit experimental. Feel free to file an issue if there are any problems.","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"set_theme!(resolution=(800, 800)) #hide\ng = smallgraph(:cubical)\nelabels_shift = [0.5 for i in 1:ne(g)]\nelabels_shift[[2,7,8,9]] .= 0.3\nelabels_shift[10] = 0.25\ngraphplot(g; layout=Spring(dim=3, seed=5),\n          elabels=\"Edge \".*repr.(1:ne(g)),\n          elabels_textsize=12,\n          elabels_opposite=[3,5,7,8,12],\n          elabels_shift,\n          elabels_distance=3,\n          arrow_show=true,\n          arrow_shift=0.9,\n          arrow_size=15)","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Using JSServe.jl and WGLMakie.jl we can also add some interactivity:","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using JSServe\nPage(exportable=true, offline=true)","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using WGLMakie\nWGLMakie.activate!()\nset_theme!(resolution=(800, 600))\ng = smallgraph(:dodecahedral)\ngraphplot(g, layout=Spring(dim=3), node_size=100)","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"","category":"page"},{"location":"generated/plots/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This page was generated using Literate.jl.","category":"page"}]
}
